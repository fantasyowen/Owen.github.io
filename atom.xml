<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Owen.Wang</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-11T03:07:18.354Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Owen.Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>post</title>
    <link href="http://yoursite.com/2019/07/11/%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>http://yoursite.com/2019/07/11/数学表达式计算/</id>
    <published>2019-07-11T02:00:39.000Z</published>
    <updated>2019-07-11T03:07:18.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何根据现有表达式和获取到的值判断值是否符合表达式"><a href="#如何根据现有表达式和获取到的值判断值是否符合表达式" class="headerlink" title="如何根据现有表达式和获取到的值判断值是否符合表达式"></a>如何根据现有表达式和获取到的值判断值是否符合表达式</h1><h3 id="背景介绍：现有一个对象有异常表达式结构如1-1-gt-30-1-1-lt-10-amp-amp-1-2-50-通过接口获取数据-check-paramtId-1-1-value-10-paramtId-1-2-value-20-paramtId-1-3-value-30-paramtId-1-4-value-40-…-。思考：怎么将异常表达式的式子代入成获取到的值并获取代入后式子的结果。"><a href="#背景介绍：现有一个对象有异常表达式结构如1-1-gt-30-1-1-lt-10-amp-amp-1-2-50-通过接口获取数据-check-paramtId-1-1-value-10-paramtId-1-2-value-20-paramtId-1-3-value-30-paramtId-1-4-value-40-…-。思考：怎么将异常表达式的式子代入成获取到的值并获取代入后式子的结果。" class="headerlink" title="背景介绍：现有一个对象有异常表达式结构如1_1&gt;=30||(1_1&lt;10&amp;&amp;1_2=50) ,通过接口获取数据{[check:{paramtId:1_1,value:10},{paramtId:1_2,value:20},{paramtId:1_3,value:30},{paramtId:1_4,value:40}…]}。思考：怎么将异常表达式的式子代入成获取到的值并获取代入后式子的结果。"></a>背景介绍：现有一个对象有异常表达式结构如1_1&gt;=30||(1_1&lt;10&amp;&amp;1_2=50) ,通过接口获取数据{[check:{paramtId:1_1,value:10},{paramtId:1_2,value:20},{paramtId:1_3,value:30},{paramtId:1_4,value:40}…]}。思考：怎么将异常表达式的式子代入成获取到的值并获取代入后式子的结果。</h3><p>最开始考虑将整个表达式分割成单个表达式，分别计算单个表达式的结果最后再&amp;&amp;或者||连接每个 结果。但是发现表达式中可能有括号，优先级计算等诸多问题，最终放弃。经Android小伙伴启发可以找Expression 库，可以直接将表达式的式子代入成值得出结果。Expression库可以帮你处理逻辑判断和优先级问题。 </p><h2 id="Expression-库-Expression-完美支持表达式解析"><a href="#Expression-库-Expression-完美支持表达式解析" class="headerlink" title="Expression 库 Expression 完美支持表达式解析"></a>Expression 库 <a href="https://github.com/nicklockwood/Expression" target="_blank" rel="noopener">Expression</a> 完美支持表达式解析</h2><p>下面上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/// 将表达式转成只有式子并排过序的数组 1_1&gt;=100&amp;&amp;1_11=10 ==&gt;[&quot;1_1&quot;,&quot;1_11&quot;]</span><br><span class="line">    private func getExpressionSortedArray(expression:String) -&gt;[String]&#123;</span><br><span class="line">        var newExpression = &quot;&quot;</span><br><span class="line">        newExpression = expression.replacingOccurrences(of: &quot;(&quot;, with: &quot;&quot;)</span><br><span class="line">        newExpression = expression.replacingOccurrences(of: &quot;)&quot;, with: &quot;&quot;)</span><br><span class="line">        newExpression = newExpression.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;)</span><br><span class="line">        var expressArr = [String]() //所有简单表达式</span><br><span class="line">        var orArr = [String]()</span><br><span class="line">        var copyOrArr:[String]</span><br><span class="line">        var andArr = [String]()</span><br><span class="line">        // 先按||分</span><br><span class="line">        if newExpression .contains(&quot;||&quot;) &#123;</span><br><span class="line">            orArr = newExpression.components(separatedBy: &quot;||&quot;)</span><br><span class="line">            if !orArr.isEmpty,orArr.count&gt;0 &#123;</span><br><span class="line">                copyOrArr = orArr</span><br><span class="line">                for index in 0..&lt;copyOrArr.count &#123;</span><br><span class="line">                    let orExp = copyOrArr[index]</span><br><span class="line">                    if orExp .contains(&quot;&amp;&amp;&quot;)&#123;</span><br><span class="line">                        andArr = orExp.components(separatedBy: &quot;&amp;&amp;&quot;)</span><br><span class="line">                        orArr.remove(at:index)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if newExpression .contains(&quot;&amp;&amp;&quot;)&#123;</span><br><span class="line">             andArr = newExpression.components(separatedBy: &quot;&amp;&amp;&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for orExpre in orArr &#123;</span><br><span class="line">            expressArr.append(orExpre)</span><br><span class="line">        &#125;</span><br><span class="line">        for andExpre in andArr &#123;</span><br><span class="line">            expressArr.append(andExpre)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var exprePreArr = [String]() //存h式子的数组</span><br><span class="line">        for indexe in 0..&lt;expressArr.count &#123;</span><br><span class="line">            let subExpre = expressArr[indexe]</span><br><span class="line">            if subExpre.contains(&quot;&gt;=&quot;) &#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;&gt;=&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;else if subExpre.contains(&quot;&lt;=&quot;)&#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;&lt;=&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;else if subExpre.contains(&quot;==&quot;)&#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;==&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;else if subExpre.contains(&quot;!=&quot;)&#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;!=&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;else if subExpre.contains(&quot;&lt;&quot;)&#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;&lt;&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;else if subExpre.contains(&quot;&gt;&quot;)&#123;</span><br><span class="line">                var temparr = subExpre.components(separatedBy: &quot;&gt;&quot;)</span><br><span class="line">                exprePreArr.append(temparr[0])</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let list = exprePreArr.sorted &#123;</span><br><span class="line">            $0.count &gt;= $1.count</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一步：<br>  先将表达式里面的 “()”和空格去掉，因为我们不需要关心优先级。</p><figure class="highlight plain"><figcaption><span>newExpression </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newExpression = expression.replacingOccurrences(of: &quot;(&quot;, with: &quot;&quot;)</span><br><span class="line">newExpression = expression.replacingOccurrences(of: &quot;)&quot;, with: &quot;&quot;)</span><br><span class="line">newExpression = newExpression.replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;)</span><br></pre></td></tr></table></figure></li><li><p>第二步：<br>  将整个表达式按 || 符号分成多个表达式，放入orArr中，然后copy一份遍历，如果式子中有&amp;&amp;符号 就按照&amp;&amp;再分割并放到andArr中，将orArr中的这一项移除。现在都是简单的数学表达式</p></li></ul>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expressArr = [<span class="type">String</span>]() <span class="comment">//所有简单表达式</span></span><br><span class="line">        <span class="keyword">var</span> orArr = [<span class="type">String</span>]()</span><br><span class="line">        <span class="keyword">var</span> copyOrArr:[<span class="type">String</span>]</span><br><span class="line">        <span class="keyword">var</span> andArr = [<span class="type">String</span>]()</span><br><span class="line">        <span class="comment">// 先按||分</span></span><br><span class="line">        <span class="keyword">if</span> newExpression .<span class="built_in">contains</span>(<span class="string">"||"</span>) &#123;</span><br><span class="line">            orArr = newExpression.components(separatedBy: <span class="string">"||"</span>)</span><br><span class="line">            <span class="keyword">if</span> !orArr.isEmpty,orArr.<span class="built_in">count</span>&gt;<span class="number">0</span> &#123;</span><br><span class="line">                copyOrArr = orArr</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;copyOrArr.<span class="built_in">count</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> orExp = copyOrArr[index]</span><br><span class="line">                    <span class="keyword">if</span> orExp .<span class="built_in">contains</span>(<span class="string">"&amp;&amp;"</span>)&#123;</span><br><span class="line">                        andArr = orExp.components(separatedBy: <span class="string">"&amp;&amp;"</span>)</span><br><span class="line">                        orArr.remove(at:index)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> newExpression .<span class="built_in">contains</span>(<span class="string">"&amp;&amp;"</span>)&#123;</span><br><span class="line">             andArr = newExpression.components(separatedBy: <span class="string">"&amp;&amp;"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>   所有式子都放到一个数组中</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> orExpre <span class="keyword">in</span> orArr &#123;</span><br><span class="line">    expressArr.append(orExpre)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> andExpre <span class="keyword">in</span> andArr &#123;</span><br><span class="line">    expressArr.append(andExpre)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第三步<br> 数学表达式解析，只去数学符号前面部分;同时做一个排序。<br>为什么要排序？<br>假如 表达式是这样的 1_1==30&amp;&amp;11_1=50&amp;&amp;1-11=100 ，如何不排序先替换1_1的时候，后面都会受影响的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exprePreArr = [<span class="type">String</span>]() <span class="comment">//存h式子的数组</span></span><br><span class="line">       <span class="keyword">for</span> indexe <span class="keyword">in</span> <span class="number">0</span>..&lt;expressArr.<span class="built_in">count</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> subExpre = expressArr[indexe]</span><br><span class="line">           <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"&gt;="</span>) &#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"&gt;="</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"&lt;="</span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"&lt;="</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"=="</span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"=="</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"!="</span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"!="</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"&lt;"</span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"&lt;"</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> subExpre.<span class="built_in">contains</span>(<span class="string">"&gt;"</span>)&#123;</span><br><span class="line">               <span class="keyword">var</span> temparr = subExpre.components(separatedBy: <span class="string">"&gt;"</span>)</span><br><span class="line">               exprePreArr.append(temparr[<span class="number">0</span>])</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">let</span> list = exprePreArr.sorted &#123;</span><br><span class="line">           $<span class="number">0</span>.<span class="built_in">count</span> &gt;= $<span class="number">1</span>.<span class="built_in">count</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>第四步</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expressionKeys = <span class="keyword">self</span>.getExpressionSortedArray(expression:    currentExpression)</span><br><span class="line"><span class="keyword">for</span> exkey <span class="keyword">in</span> expressionKeys &#123;</span><br><span class="line">    <span class="keyword">if</span> !iotCheckDic.isEmpty,iotCheckDic.keys.<span class="built_in">contains</span>(exkey) &#123;</span><br><span class="line">                <span class="keyword">for</span> iotCheck <span class="keyword">in</span> iotCheckDic &#123;</span><br><span class="line">                    <span class="keyword">if</span> iotCheck.key == exkey &#123;</span><br><span class="line">                      currentExpression =    currentExpression.replacingOccurrences(of: exkey, with:iotCheck.value)</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> isException</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">let value = try Expression(currentExpression,options:.boolSymbols).evaluate()</span><br><span class="line">            if value == 1 &#123;</span><br><span class="line">                    isException = true</span><br><span class="line">            &#125;</span><br><span class="line">            &#125; catch &#123;</span><br><span class="line">                NSLog(&quot;判断字符串表示式时异常&quot;, &quot;\(error)&quot;)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>.boolSymbols 是返回bool的表达式。 value == 1 表示的是字符串表达式的值为true，0表示false。</p></li></ul><h3 id="搞定收工。"><a href="#搞定收工。" class="headerlink" title="搞定收工。"></a>搞定收工。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何根据现有表达式和获取到的值判断值是否符合表达式&quot;&gt;&lt;a href=&quot;#如何根据现有表达式和获取到的值判断值是否符合表达式&quot; class=&quot;headerlink&quot; title=&quot;如何根据现有表达式和获取到的值判断值是否符合表达式&quot;&gt;&lt;/a&gt;如何根据现有表达式和获
      
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="数学表达式求值" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中奇怪的语法 ——</title>
    <link href="http://yoursite.com/2019/06/21/Swift/"/>
    <id>http://yoursite.com/2019/06/21/Swift/</id>
    <published>2019-06-21T08:55:55.000Z</published>
    <updated>2019-06-21T09:25:46.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-中奇怪的语法-——-selector"><a href="#Swift-中奇怪的语法-——-selector" class="headerlink" title="Swift 中奇怪的语法 —— #selector"></a>Swift 中奇怪的语法 —— #selector</h1><h3 id="iOS-selector-的用法"><a href="#iOS-selector-的用法" class="headerlink" title="iOS selector 的用法"></a>iOS selector 的用法</h3><p>@selector (OC写法)/#selector 常用于 <code>Timer</code> 和 <code>UIBarButtonItem</code>等类中的target/action方法中。例如，当你创建计时器时，你需要告诉它在计时器触发时通知<strong>谁（target）</strong>以及应该调用哪个<strong>方法（action）</strong>。对于BarButtonItem 也是如此：当按下按钮时，应该调用哪个选择器，以及在什么对象上？</p><h3 id="Swift的-selector和Oc的-selector一样。"><a href="#Swift的-selector和Oc的-selector一样。" class="headerlink" title="Swift的#selector和Oc的@selector一样。"></a>Swift的#selector和Oc的@selector一样。</h3><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>Swift 有函数重载 overload (同名，不同参数)的概念，而Oc没有。所以在Swift中使用#selector时需要消除选择引用哪个函数的歧义。</p><p>例如：这个类中有一个重载的方法 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">Student</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">​<span class="function"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(some: Int)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​<span class="function"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(some: Int, any: String)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">​&#125;</span><br></pre></td></tr></table></figure><p>当你直接调用doSomeThing() 时，Swift可以根据你传递的参数确定你调用的是哪个，但是用#selector调用的话无法知道参数的类型。</p><h1 id="解决方法就是加入参数标签："><a href="#解决方法就是加入参数标签：" class="headerlink" title="解决方法就是加入参数标签："></a>解决方法就是加入参数标签：</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#selector(<span class="type">Student</span>.doSomeThing(some:any:)))</span><br></pre></td></tr></table></figure><p>这个时候selector就知道调用的是 第二个方法了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-中奇怪的语法-——-selector&quot;&gt;&lt;a href=&quot;#Swift-中奇怪的语法-——-selector&quot; class=&quot;headerlink&quot; title=&quot;Swift 中奇怪的语法 —— #selector&quot;&gt;&lt;/a&gt;Swift 中奇怪的语法 
      
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="iOS,swift" scheme="http://yoursite.com/tags/iOS-swift/"/>
    
  </entry>
  
  <entry>
    <title>克隆慢</title>
    <link href="http://yoursite.com/2019/06/17/%E5%85%8B%E9%9A%86%E6%85%A2/"/>
    <id>http://yoursite.com/2019/06/17/克隆慢/</id>
    <published>2019-06-17T03:09:57.000Z</published>
    <updated>2019-06-17T03:22:22.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今天第一次克隆iOS项目，在pod-install-时GitHub克隆特别慢"><a href="#今天第一次克隆iOS项目，在pod-install-时GitHub克隆特别慢" class="headerlink" title="今天第一次克隆iOS项目，在pod install 时GitHub克隆特别慢"></a>今天第一次克隆iOS项目，在pod install 时GitHub克隆特别慢</h1><p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p><ol><li>使用国内镜像的Specs</li><li>在pod install时使用命令<code>pod install --no-repo-update</code></li><li>使用proxychains使终端命令走代理</li></ol><p>下面就来说明一下这几种方法为何没有完全解决问题</p><ol><li>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</li><li>在pod install时使用命令<code>pod install --no-repo-update</code><br>install时不更新本地库，但如果第一次install还是要去github clone代码</li><li>使用proxychains使终端命令走代理<br>这个只是使pod命令走代理，git download的时候不会走代理</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p>执行 sudo vi /etc/hosts</p><p> i  — insert </p><p> 输入 192.30.253.113 github.com</p></li></ul><p>​        151.101.77.194 github.global.ssl.fastly.net</p><p>​        按 esc  然后 “冒号 :wq” 退出保存</p><ul><li>执行命令刷新DNS缓存<br>sudo killall -HUP mDNSResponder</li><li><p>重新 pod install </p><h4 id="自己尝试了一下还是有用的，-速度一下从-4KiB-s-干到100KiB-s-左右"><a href="#自己尝试了一下还是有用的，-速度一下从-4KiB-s-干到100KiB-s-左右" class="headerlink" title="自己尝试了一下还是有用的， 速度一下从 4KiB/s 干到100KiB/s 左右"></a>自己尝试了一下还是有用的， 速度一下从 4KiB/s 干到100KiB/s 左右</h4></li></ul><p>此记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;今天第一次克隆iOS项目，在pod-install-时GitHub克隆特别慢&quot;&gt;&lt;a href=&quot;#今天第一次克隆iOS项目，在pod-install-时GitHub克隆特别慢&quot; class=&quot;headerlink&quot; title=&quot;今天第一次克隆iOS项目，在po
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git github" scheme="http://yoursite.com/tags/git-github/"/>
    
  </entry>
  
  <entry>
    <title>Optionals</title>
    <link href="http://yoursite.com/2019/06/11/Optionals/"/>
    <id>http://yoursite.com/2019/06/11/Optionals/</id>
    <published>2019-06-11T01:40:12.000Z</published>
    <updated>2019-06-21T09:27:09.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="optionals-可选型"><a href="#optionals-可选型" class="headerlink" title="optionals 可选型"></a>optionals 可选型</h1><h3 id="可选型如果能转换成指定的类型则转换，如果不能转换则可选型为-nil"><a href="#可选型如果能转换成指定的类型则转换，如果不能转换则可选型为-nil" class="headerlink" title="可选型如果能转换成指定的类型则转换，如果不能转换则可选型为 nil"></a>可选型如果能转换成指定的类型则转换，如果不能转换则可选型为 nil</h3><ul><li><p>可选型声明 — 显式声明</p><p>var a : Int ?  (在变量的类型后面加”?”) 此时 a 的默认值是nil</p><p>a = 12   // a 赋值 12</p></li><li><p>隐式</p><p>比如想让用户输入年龄,但是用户输入的并非Int类型</p><p>let  userInput =  “***”</p><p>var age = userInput.toInt()  //toInt 的返回值是Int? 意味着age将会是一个可选型的值，就意味着 age 可能为nil(比如 ：userInput = “abc” 的时候)</p><h4 id="可选型解包"><a href="#可选型解包" class="headerlink" title="可选型解包"></a>可选型解包</h4><p> var age :Int ?</p><p>age = 18</p><p>println(age) //Some 18</p><p>println(age!)  //18</p><p>println(“我的年龄是” + String(age))   //❌的，因为强制类型转换不能直接转换可选型的</p><p>println(“我的年龄是” + String(age!))  //✅的，age! 表示我已经明确知道此时age是有Int值的，</p><h6 id="在可选型变量的后面直接加-‘-’-进行解包操作"><a href="#在可选型变量的后面直接加-‘-’-进行解包操作" class="headerlink" title="在可选型变量的后面直接加 ‘!’ 进行解包操作"></a>在可选型变量的后面直接加 ‘!’ 进行解包操作</h6></li></ul><p>强制类型转换不能转换可选型,除非明确可选型有值</p><h1 id="String-和-Character"><a href="#String-和-Character" class="headerlink" title="String 和 Character"></a>String 和 Character</h1><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><p>创建一个空的字符串变量</p><p> var emptyStr = “”</p><p>Var anotherEmptyStr = String()</p></li><li><p>字符串变量 for- in</p><p>var str = “hello Owen wang”</p><p>for c  in str {</p><p>//…</p><p>}</p></li><li><p>计算字符串的长度</p><p>countElements(str)   //str 中的空格也会被算做一个字符，中文算一个字符，表情符号也是一个字符</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3></li><li><p>创建字符变量 Character</p><p>Var ch:Character = “o”</p><p>字符ch 只能有一个字符</p><p>字符串可以通过append(字符)的方式拼接字符</p><p>例如： </p><p>​        var str = “hello owen wang”</p><p>​        var ch:Character = “!”</p><p>​        str .append(ch)</p><p>​        println(str)// “hello Owen wang !”</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>​        字符串可以直接 + 字符串，但是新版本中不能直接 + 字符(Character)</p><p>​        var a =”abc”</p><p>​        var b = “def”</p><p>​        var c:Character = “g”</p><p>​        a + b // ✅ “abcdef”</p><p>​        a + c // ❌ 编译时出错，不支持字符串直接 + 字符</p></li></ul><p>  ​                </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;optionals-可选型&quot;&gt;&lt;a href=&quot;#optionals-可选型&quot; class=&quot;headerlink&quot; title=&quot;optionals 可选型&quot;&gt;&lt;/a&gt;optionals 可选型&lt;/h1&gt;&lt;h3 id=&quot;可选型如果能转换成指定的类型则转换，如果不
      
    
    </summary>
    
      <category term="Swift" scheme="http://yoursite.com/categories/Swift/"/>
    
    
      <category term="Optionals/String Character" scheme="http://yoursite.com/tags/Optionals-String-Character/"/>
    
  </entry>
  
</feed>
